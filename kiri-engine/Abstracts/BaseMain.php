<?php
/**
 * Created by PhpStorm.
 * User: whwyy
 * Date: 2018/10/7 0007
 * Time: 2:13
 */
declare(strict_types=1);

namespace Kiri\Abstracts;


use Exception;
use Kiri;
use Kiri\Di\LocalService;
use ReflectionException;
use Kiri\Error\StdoutLogger;
use Kiri\Exception\{InitException};
use Psr\Log\LoggerInterface;
use Kiri\Events\EventProvider;

/**
 * Class BaseApplication
 * @package Kiri\Base
 */
abstract class BaseMain extends Component
{


	/**
	 * @var string
	 */
	public string $storage = APP_PATH . 'storage';

	public string $envPath = APP_PATH . '.env';

	/**
	 * Init constructor.
	 *
	 *
	 * @throws
	 */
	public function __construct()
	{
		$config = sweep(APP_PATH . '/config');
		$this->mapping($config['mapping'] ?? [], $config['components']);
		$this->parseInt($config);
		$this->parseEvents($config);
		$this->enableEnvConfig();
		parent::__construct();
	}


	/**
	 * @param array $mapping
	 * @param array $components
	 * @throws ReflectionException
	 */
	public function mapping(array $mapping, array $components)
	{
		$di = Kiri::getDi();
		$di->set(LoggerInterface::class, StdoutLogger::class);
		foreach ($mapping as $interface => $class) {
			$di->set($interface, $class);
		}

		foreach ($components as $id => $component) {
			$this->set($id, $component);
		}
	}


	/**
	 * @return array
	 */
	public function enableEnvConfig(): array
	{
		if (!file_exists($this->envPath)) {
			return [];
		}
		$lines = $this->readLinesFromFile($this->envPath);
		foreach ($lines as $line) {
			if (!$this->isComment($line) && $this->looksLikeSetter($line)) {
				[$key, $value] = explode('=', $line);
				putenv(trim($key) . '=' . trim($value));
			}
		}
		return $lines;
	}


	/**
	 * Read lines from the file, auto detecting line endings.
	 *
	 * @param string $filePath
	 *
	 * @return array
	 */
	protected function readLinesFromFile(string $filePath): array
	{
		// Read file into an array of lines with auto-detected line endings
//		$autodetect = ini_get('auto_detect_line_endings');
//		ini_set('auto_detect_line_endings', '1');
		//		ini_set('auto_detect_line_endings', $autodetect);

		return file($filePath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
	}

	/**
	 * Determine if the line in the file is a comment, e.g. begins with a #.
	 *
	 * @param string $line
	 *
	 * @return bool
	 */
	protected function isComment(string $line): bool
	{
		$line = ltrim($line);

		return isset($line[0]) && $line[0] === '#';
	}

	/**
	 * Determine if the given line looks like it's setting a variable.
	 *
	 * @param string $line
	 *
	 * @return bool
	 */
	protected function looksLikeSetter(string $line): bool
	{
		return str_contains($line, '=');
	}


	/**
	 * @param $config
	 *
	 * @throws
	 */
	public function parseInt($config)
	{
		Config::sets($config);
		if ($storage = Config::get('storage', 'storage')) {
			if (!str_contains($storage, APP_PATH)) {
				$storage = APP_PATH . $storage . '/';
			}
			if (!is_dir($storage)) {
				mkdir($storage);
			}
			if (!is_dir($storage) || !is_writeable($storage)) {
				throw new InitException("Directory {$storage} does not have write permission");
			}
		}
	}

	/**
	 * @param $config
	 *
	 * @throws
	 */
	public function parseEvents($config)
	{
		if (!isset($config['events']) || !is_array($config['events'])) {
			return;
		}
		foreach ($config['events'] as $key => $value) {
			if (is_string($value)) {
				$value = Kiri::createObject($value);
			}
			$this->addEvent($key, $value);
		}
	}


	/**
	 * @param $key
	 * @param $value
	 * @return void
	 * @throws InitException
	 * @throws Exception
	 */
	private function addEvent($key, $value): void
	{
		$provider = Kiri::getDi()->get(EventProvider::class);
		if ($value instanceof \Closure || is_object($value)) {
			$provider->on($key, $value, 0);
			return;
		}
		if (!is_array($value)) {
			return;
		}
		if (is_object($value[0]) && !($value[0] instanceof \Closure)) {
			$provider->on($key, $value, 0);
			return;
		} else if (is_string($value[0])) {
			$value[0] = Kiri::createObject($value[0]);
			$provider->on($key, $value, 0);
			return;
		}
		foreach ($value as $item) {
			if (!is_callable($item, true)) {
				throw new InitException("Class does not hav callback.");
			}
			$provider->on($key, $item, 0);
		}
	}


	/**
	 * @return mixed
	 */
	public function getLocalIps(): mixed
	{
		return swoole_get_local_ip();
	}


	/**
	 * @return mixed
	 */
	public function getFirstLocal(): mixed
	{
		return current($this->getLocalIps());
	}


	/**
	 * @param string $name
	 * @return mixed|null
	 * @throws Exception
	 */
	public function __get(string $name)
	{
		$localService = Kiri::getDi()->get(LocalService::class);
		if ($localService->has($name)) {
			return $localService->get($name);
		}
		return parent::__get($name); // TODO: Change the autogenerated stub
	}


	/**
	 * @param $id
	 * @param $definition
	 * @throws ReflectionException
	 */
	public function set($id, $definition): void
	{
		Kiri::getDi()->get(LocalService::class)->set($id, $definition);
	}


	/**
	 * @param $id
	 * @return bool
	 * @throws ReflectionException
	 */
	public function has($id): bool
	{
		return Kiri::getDi()->get(LocalService::class)->has($id);
	}
}
